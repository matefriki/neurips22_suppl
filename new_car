mdp

const int street_length = 100;
const int sidewalk_height = 2;

const int crosswalk_pos = 80;
const int crosswalk_width = 10;
const int crosswalk_height = 11;

const int max_speed = 3;

const int maxblocklength = 5;
const int maxblockheight = 5;
//const in

//const int vis_length = 50; // 50 pixels visible in front
//const double omega = 3.14159265358979323/3; // 60 degree angle
//formula tan_x = omega + (1/3)*(pow(omega, 3)) + (2/15)*(pow(omega, 5)) + (17/315)*(pow(omega, 7)) + (62/2835)*(pow(omega, 9)); 
// const double vis_cone = tan_x;

const double neutral = 0.5;
const double change_prob1 = 0.7;
const double change_prob2 = 1 - change_prob1;

// block properties

//const int block_height = 2;
//const int block_width = 5;
//const int block_x1 = crosswalk_pos - 5;
//const int block_y1 = sidewalk_height;
//const int block_x2 = block_x1 + block_width;
//const int block_y2 = sidewalk_height + block_height;

// car properties
const int car_height = 2;
const int car_width = max_speed;

const int world_height = (sidewalk_height * 2) + crosswalk_height;

global turn : [0..2] init 0;

label "crash" = ((ped_x >= car_x) & (ped_x <= ped_x + car_width)) & ((ped_y >= car_y) & (ped_y <= car_y + car_height));
label "blocked_vis" = blocked_view;

formula dist = max(ped_x-car_x, car_x - ped_x) + max(ped_y - car_y, car_y - ped_y);	
formula safe_dist = dist > 15;
formula is_on_sidewalk = (ped_y < sidewalk_height) | (ped_y > sidewalk_height + crosswalk_height);
formula wait_prob = (crosswalk_pos - ped_x) / 10;

// for calculating if pedestrian is blocked from car view
formula x1 = car_x + car_width;
formula y1 = car_y;
formula x2 = ped_x;
formula y2 = ped_y;

formula block_x2 = block_x1 + block_width;
formula block_y2 = block_y1 + block_height;

// block origin is below car origin & above car origin - vision is blocked if line from car to pedestrian crosses through the block on the 
formula block_q4 = (((((y2 -  y1)/(x2 - x1))*(block_x1 - x1) + y1) > block_y1) & ((((y2 -  y1)/(x2 - x1))*(block_x1 - x1) + y1) < block_y2)) | (((((x2 - x1)/(y2 - y1))*(block_y2 - y1) + x1) > block_x1) & ((((x2 - x1)/(y2 - y1))*(block_y2 - y1) + x1) < block_x2));
formula block_q1 = (((((y2 -  y1)/(x2 - x1))*(block_x1 - x1) + y1) > block_y1) & ((((y2 -  y1)/(x2 - x1))*(block_x1 - x1) + y1) < block_y2)) | (((((x2 - x1)/(y2 - y1))*(block_y1 - y1) + x1) > block_x1) & ((((x2 - x1)/(y2 - y1))*(block_y1 - y1) + x1) < block_x2));
formula blocked_view = block_q4 | block_q1;


module Car
	car_x : [0..street_length] init 0;
	car_v : [0..max_speed] init 0;
	car_y : [sidewalk_height..world_height-sidewalk_height] init 5;
	visibility : [0..1] init 1;

	// block properties
	block_height : [0..maxblocklength] init 2;
	block_width : [0..maxblockheight] init 5;
	block_x1 : [0..(street_length-maxblocklength)] init (crosswalk_pos - 5);
	block_y1 : [0..(world_height-maxblockheight)] init sidewalk_height;

 
	// TO-DO: figure out why/when the car would accelerate/brake (e.g. ped in vis)
	[] (turn = 0) & safe_dist -> // Accelerate
		// change_prob/neutral/... etc. based on type of driver
		0.5: (car_v' = min(max_speed, car_v + 1))&(car_x' = min(street_length, car_x + min(max_speed, car_v + 1)))&(turn' = 1) +
		0.5: (car_v' = min(max_speed, car_v + 2))&(car_x' = min(street_length, car_x + min(max_speed, car_v + 2)))&(turn' = 1);
	[] (turn = 0)  -> // Brake
		// probability changes based on type of driver e.g. aggressive: +/- 2 then higher probability, cautious: then lower probability
		0.5: (car_v' = max(0, car_v - 1))&(car_x' = min(street_length, car_x + max(0, car_v - 1)))&(turn' = 1) +
		0.5: (car_v' = max(0, car_v - 2))&(car_x' = min(street_length, car_x + max(0, car_v - 2)))&(turn' = 1);

	[] (turn = 0) ->
		(car_x' = min(street_length, car_x + max(0, car_v)))&(turn' = 1);

	[] (turn = 1)& !blocked_view -> (visibility' = 0)&(turn' = 2);
	[] (turn = 1)& blocked_view -> (visibility' = 1)&(turn' = 2);

	
endmodule

module Pedestrian
	ped_x : [0..street_length] init (crosswalk_pos + 5); 
	ped_y : [0..world_height] init 0;
	

	[] (is_on_sidewalk)&(turn = 2) -> // pedestrian choices from the sidewalk
		0.25: (ped_y' = min(ped_y + 1, world_height))&(turn' = 0) + // Up
		0.25: (ped_y' = max(ped_y - 1, 0))&(turn' = 0) + // Down
		0.25: (ped_x' = max(ped_x - 1, 0))&(turn' = 0) + // Left
		0.25: (ped_x' = min(ped_x + 1, street_length))&(turn' = 0); // Right
//	[] (!is_on_sidewalk)&(turn = 2) -> // pedestrian choices from the crosswalk
//		0.9: (ped_y' = min(ped_y + 1, world_height))&(turn' = 0) + // Up
//		0.1: (ped_y' = max(ped_y - 1, 0))&(turn' = 0); // Down

	// trying to increase probability that ped is hidden from view of car
	// ped crosses when car is close to crosswalk
	[] (!is_on_sidewalk)&(turn = 2) -> // pedestrian choices from the crosswalk
		0.5: (ped_y' = min(ped_y + 1, world_height))&(turn' = 0) + // Up
		0.5: (ped_y' = max(ped_y - 1, 0))&(turn' = 0); // Down
	[] (!is_on_sidewalk)&(!safe_dist)&(turn = 2) -> // pedestrian choices from the crosswalk
		0.9: (ped_y' = min(ped_y + 1, world_height))&(turn' = 0) + // Up
		0.1: (ped_y' = max(ped_y - 1, 0))&(turn' = 0); // Down
endmodule

